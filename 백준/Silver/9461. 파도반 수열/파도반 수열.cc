#include <iostream>

#define MAX 101 // N의 최대값이 100이므로 배열 크기는 101로 설정

using namespace std;

// P(N) 값을 저장할 배열 (동적 프로그래밍 - 메모이제이션)
// long long으로 선언하는 것이 좋습니다. P(100)은 int 범위를 넘어설 수 있습니다.
// 문제 제약조건에서 N이 100까지이고, P(100)은 약 1.8 * 10^11 이므로 int로는 부족합니다.
long long dp[MAX] = {0,};

int main() {
    ios_base::sync_with_stdio(false); // C++ 표준 스트림과 C 표준 스트림 동기화 해제
    cin.tie(NULL);                    // cin과 cout의 묶음 해제 (입출력 속도 향상)

    int T; // 테스트 케이스의 수
    int N; // 파도반 수열의 N번째 항

    // 파도반 수열의 초기값 설정
    // 문제에서 P(1)부터 P(10)까지 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 로 주어졌습니다.
    // 이를 만족하는 점화식은 P(N) = P(N-1) + P(N-5) 이고,
    // 그에 따른 초기값 P(1)부터 P(5)는 다음과 같습니다.
    dp[1] = 1;
    dp[2] = 1;
    dp[3] = 1;
    dp[4] = 2; // dp[3] + dp[-1] (X) -> 문제에서 주어진 값
    dp[5] = 2; // dp[4] + dp[0] (X) -> 문제에서 주어진 값

    // P(6) 부터 P(100) 까지의 값을 미리 계산 (최대 N이 100이므로)
    // 이렇게 하면 각 테스트 케이스마다 반복적으로 계산할 필요가 없습니다.
    for (int i = 6; i <= 100; i++) {
        dp[i] = dp[i - 1] + dp[i - 5];
    }

    cin >> T; // 테스트 케이스 수 입력
    while (T--) {
        cin >> N; // N 입력
        cout << dp[N] << "\n"; // 계산된 P(N) 값 출력
    }

    return 0;
}